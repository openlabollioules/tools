[{"id":"generate_excel_files","user_id":"5bfef5b3-563f-4ac3-a849-feeab72fbe46","name":"generate excel files","content":"\"\"\"\ntitle: Generate Excel Document\nauthor: openlab\nversion: 0.1\nlicense: MIT\ndescription: Génère un fichier Excel via un LLM (Ollama) et renvoie un lien de téléchargement\n\"\"\"\n\nimport os, uuid\nfrom typing import Optional, Callable, Any, List, Dict\nfrom pathlib import Path\nfrom fastapi import UploadFile, Request\nimport re\nimport json\nfrom openpyxl import Workbook\nfrom openpyxl.styles import Font, Alignment, PatternFill, Border, Side\nfrom openpyxl.utils import get_column_letter\nfrom openpyxl.worksheet.table import Table, TableStyleInfo\n\nfrom open_webui.routers.files import upload_file\nfrom open_webui.models.users import Users\nfrom open_webui.storage.provider import Storage\nfrom open_webui.models.files import Files, FileForm\n\n\nclass EventEmitter:\n    def __init__(self, event_emitter: Callable[[dict], Any] = None):\n        self.event_emitter = event_emitter\n\n    async def emit(self, description=\"Unknown State\", status=\"in_progress\", done=False):\n        if self.event_emitter:\n            await self.event_emitter(\n                {\n                    \"type\": \"status\",\n                    \"data\": {\n                        \"status\": status,\n                        \"description\": description,\n                        \"done\": done,\n                    },\n                }\n            )\n\n\nclass HelpFunctions:\n    def __init__(self):\n        self.default_fonts = {\n            \"main\": \"Calibri\",\n            \"header\": \"Arial\",\n        }\n        self.colors = {\"header_bg\": \"1F4E78\", \"alt_row\": \"F2F2F2\", \"grid\": \"D3D3D3\"}\n\n    def format_header_row(self, worksheet, row_num, columns):\n        \"\"\"\n        Format the header row with styling.\n\n        Args:\n            worksheet: The Excel worksheet.\n            row_num (int): The row number for the header.\n            columns (list): List of column names.\n        \"\"\"\n        # Define styles\n        header_font = Font(name=self.default_fonts[\"header\"], bold=True, color=\"FFFFFF\")\n        header_fill = PatternFill(\n            start_color=self.colors[\"header_bg\"],\n            end_color=self.colors[\"header_bg\"],\n            fill_type=\"solid\",\n        )\n        header_alignment = Alignment(\n            horizontal=\"center\", vertical=\"center\", wrap_text=True\n        )\n\n        # Apply styles to header row\n        for col_idx, column_name in enumerate(columns, 1):\n            cell = worksheet.cell(row=row_num, column=col_idx)\n            cell.value = column_name\n            cell.font = header_font\n            cell.fill = header_fill\n            cell.alignment = header_alignment\n\n            # Adjust column width based on content\n            column_letter = get_column_letter(col_idx)\n            worksheet.column_dimensions[column_letter].width = max(\n                12, len(column_name) + 2\n            )\n\n    def format_data_rows(self, worksheet, start_row, end_row, num_cols):\n        \"\"\"\n        Format the data rows with alternating colors and borders.\n\n        Args:\n            worksheet: The Excel worksheet.\n            start_row (int): Starting row number for data.\n            end_row (int): Ending row number for data.\n            num_cols (int): Number of columns.\n        \"\"\"\n        # Define styles\n        alt_fill = PatternFill(\n            start_color=self.colors[\"alt_row\"],\n            end_color=self.colors[\"alt_row\"],\n            fill_type=\"solid\",\n        )\n        thin_border = Border(\n            left=Side(style=\"thin\", color=self.colors[\"grid\"]),\n            right=Side(style=\"thin\", color=self.colors[\"grid\"]),\n            top=Side(style=\"thin\", color=self.colors[\"grid\"]),\n            bottom=Side(style=\"thin\", color=self.colors[\"grid\"]),\n        )\n\n        # Apply styles to data rows\n        for row in range(start_row, end_row + 1):\n            # Apply alternating row colors\n            if row % 2 == 0:\n                for col in range(1, num_cols + 1):\n                    worksheet.cell(row=row, column=col).fill = alt_fill\n\n            # Apply borders to all cells\n            for col in range(1, num_cols + 1):\n                worksheet.cell(row=row, column=col).border = thin_border\n                worksheet.cell(row=row, column=col).alignment = Alignment(\n                    horizontal=\"left\", vertical=\"center\"\n                )\n\n    def create_excel_table(self, worksheet, start_row, end_row, num_cols, table_name):\n        \"\"\"\n        Create an Excel table from the data range.\n\n        Args:\n            worksheet: The Excel worksheet.\n            start_row (int): Starting row number for table.\n            end_row (int): Ending row number for table.\n            num_cols (int): Number of columns.\n            table_name (str): Name for the table.\n        \"\"\"\n        # Define table range\n        table_ref = f\"A{start_row}:{get_column_letter(num_cols)}{end_row}\"\n\n        # Create table\n        table = Table(displayName=table_name, ref=table_ref)\n\n        # Add a default style\n        style = TableStyleInfo(\n            name=\"TableStyleMedium9\",\n            showFirstColumn=False,\n            showLastColumn=False,\n            showRowStripes=True,\n            showColumnStripes=False,\n        )\n        table.tableStyleInfo = style\n\n        # Add the table to the worksheet\n        worksheet.add_table(table)\n\n    def format_worksheet(self, worksheet, title):\n        \"\"\"\n        Apply general formatting to the worksheet.\n\n        Args:\n            worksheet: The Excel worksheet.\n            title (str): Title for the worksheet.\n        \"\"\"\n        # Set worksheet title\n        worksheet.title = title[:31]  # Excel limits worksheet names to 31 chars\n\n        # Add title at the top\n        title_cell = worksheet.cell(row=1, column=1)\n        title_cell.value = title\n        title_cell.font = Font(size=14, bold=True)\n\n        # Merge cells for title\n        worksheet.merge_cells(\"A1:D1\")\n        title_cell.alignment = Alignment(horizontal=\"center\")\n\n        # Add some space below title\n        worksheet.row_dimensions[2].height = 10\n\n\n# --- Tools ---\nclass Tools:\n    def __init__(self):\n        self.FILES_DIR = \"./tmp\"\n        self.API_BASE_URL = \"http://localhost:3000/api/v1/files/\"\n        os.makedirs(self.FILES_DIR, exist_ok=True)\n        self.help_functions = HelpFunctions()\n        self.event_emitter = EventEmitter()\n\n    async def generate_excel_from_json(\n        self,\n        json_data: dict,\n        __request__: Request,\n        __event_emitter__: Callable[[dict], Any] = None,\n        __user__=None,\n    ):\n        \"\"\"\n        Generate an Excel document from a JSON file.\n\n        Args:\n            json_data: The JSON data to generate the document from.\n            __user__: The user to upload the file to.\n        Returns:\n            str: The download URL of the uploaded file.\n\n        Example:\n        Here is an example of the JSON data for a complete Excel document:\n\n        ```json\n        {\n            \"titre\": \"Rapport financier\",\n            \"feuilles\": [\n                {\n                    \"nom\": \"Résumé\",\n                    \"tableau\": {\n                        \"colonnes\": [\"Mois\", \"Revenus\", \"Dépenses\", \"Profit\"],\n                        \"données\": [\n                            [\"Janvier\", 10000, 8000, 2000],\n                            [\"Février\", 12000, 7500, 4500],\n                            [\"Mars\", 15000, 9000, 6000]\n                        ]\n                    }\n                },\n                {\n                    \"nom\": \"Détails dépenses\",\n                    \"tableau\": {\n                        \"colonnes\": [\"Catégorie\", \"Montant\", \"Pourcentage\"],\n                        \"données\": [\n                            [\"Salaires\", 5000, \"60%\"],\n                            [\"Loyer\", 1500, \"20%\"],\n                            [\"Fournitures\", 800, \"10%\"],\n                            [\"Marketing\", 500, \"5%\"],\n                            [\"Divers\", 400, \"5%\"]\n                        ]\n                    }\n                }\n            ]\n        }\n        ```\n        \"\"\"\n        emitter = EventEmitter(__event_emitter__)\n        print(\"[DEBUG] json_data\", json_data)\n        titre = json_data.get(\"titre\")\n        print(\"[DEBUG] titre\", titre)\n        await emitter.emit(f\"Initiating Excel generation for: {titre}\")\n\n        # Create workbook\n        wb = Workbook()\n        print(\"[DEBUG] workbook created\")\n\n        # Remove default worksheet if we have sheets defined\n        if json_data.get(\"feuilles\") and len(json_data.get(\"feuilles\")) > 0:\n            if \"Sheet\" in wb.sheetnames:\n                del wb[\"Sheet\"]\n\n        # Process each sheet\n        try:\n            await emitter.emit(\"Creating Excel sheets and tables\")\n\n            for sheet_idx, sheet_data in enumerate(json_data.get(\"feuilles\", [])):\n                sheet_name = sheet_data.get(\"nom\", f\"Feuille {sheet_idx+1}\")\n\n                # Create new worksheet\n                if sheet_idx == 0 and \"Sheet\" in wb.sheetnames:\n                    # Use default sheet for first worksheet\n                    ws = wb.active\n                    ws.title = sheet_name\n                else:\n                    ws = wb.create_sheet(title=sheet_name)\n\n                print(f\"[DEBUG] Created sheet: {sheet_name}\")\n\n                # Format worksheet with title\n                self.help_functions.format_worksheet(\n                    ws, sheet_data.get(\"nom\", sheet_name)\n                )\n\n                # Process table data\n                if \"tableau\" in sheet_data:\n                    # Get table data\n                    table_data = sheet_data[\"tableau\"]\n                    columns = table_data.get(\"colonnes\", [])\n                    data_rows = table_data.get(\"données\", [])\n\n                    # Start position (after title and spacing)\n                    header_row = 3\n\n                    # Add header\n                    self.help_functions.format_header_row(ws, header_row, columns)\n\n                    # Add data\n                    for row_idx, row_data in enumerate(data_rows, header_row + 1):\n                        for col_idx, cell_value in enumerate(row_data, 1):\n                            ws.cell(row=row_idx, column=col_idx).value = cell_value\n\n                    # Format data rows\n                    if data_rows:\n                        end_row = header_row + len(data_rows)\n                        self.help_functions.format_data_rows(\n                            ws, header_row + 1, end_row, len(columns)\n                        )\n\n                        # Create Excel table\n                        table_name = f\"Table{sheet_idx}\".replace(\" \", \"\")\n                        try:\n                            self.help_functions.create_excel_table(\n                                ws, header_row, end_row, len(columns), table_name\n                            )\n                        except Exception as e:\n                            print(f\"[DEBUG] Could not create table: {e}\")\n\n                # Add simple formulas if it's a numeric table\n                if \"tableau\" in sheet_data:\n                    columns = sheet_data[\"tableau\"].get(\"colonnes\", [])\n                    data_rows = sheet_data[\"tableau\"].get(\"données\", [])\n\n                    if data_rows and len(data_rows) > 0:\n                        numeric_cols = []\n\n                        # Detect numeric columns\n                        for col_idx, _ in enumerate(columns, 1):\n                            if all(\n                                isinstance(row[col_idx - 1], (int, float))\n                                for row in data_rows\n                                if col_idx - 1 < len(row)\n                            ):\n                                numeric_cols.append(col_idx)\n\n                        # Add totals row with formulas\n                        if numeric_cols:\n                            total_row = header_row + len(data_rows) + 1\n                            ws.cell(row=total_row, column=1).value = \"Total\"\n                            ws.cell(row=total_row, column=1).font = Font(bold=True)\n\n                            for col_idx in numeric_cols:\n                                col_letter = get_column_letter(col_idx)\n                                start_row = header_row + 1\n                                end_row = header_row + len(data_rows)\n                                formula = f\"=SUM({col_letter}{start_row}:{col_letter}{end_row})\"\n                                ws.cell(row=total_row, column=col_idx).value = formula\n                                ws.cell(row=total_row, column=col_idx).font = Font(\n                                    bold=True\n                                )\n\n            await emitter.emit(\n                status=\"complete\",\n                description=f\"Excel generation completed\",\n                done=True,\n            )\n        except Exception as e:\n            print(\"[DEBUG] Error\", e)\n            return f\"Error: {str(e)}\"\n\n        # Save workbook\n        if not os.path.exists(self.FILES_DIR):\n            os.makedirs(self.FILES_DIR)\n        # clean up title for filename\n        clean_title = re.sub(r\"[^\\w\\s]\", \"\", json_data.get(\"titre\", \"excel\"))\n        clean_title = clean_title.replace(\" \", \"_\")\n\n        output_path = self.FILES_DIR + \"/\" + clean_title + \".xlsx\"\n        wb.save(output_path)\n        print(\"[DEBUG] output_path\", output_path)\n\n        try:\n            with open(output_path, \"rb\") as f:\n                print(\"[DEBUG] f\", f)\n                files = UploadFile(file=f, filename=os.path.basename(output_path))\n                print(\"[DEBUG] files\", files)\n                file_item = await self.upload_file(\n                    file=files,\n                    user_id=__user__[\"id\"],\n                    __request__=__request__,\n                    __user__=__user__,\n                    __event_emitter__=__event_emitter__,\n                )\n                print(\"[DEBUG] file_item\", file_item)\n                return file_item\n        except Exception as e:\n            print(\"[DEBUG] Error\", e)\n            return f\"Error: {str(e)}\"\n\n    async def upload_file(\n        self,\n        file: UploadFile,\n        user_id: str,\n        __request__: Request,\n        __user__: dict,\n        __event_emitter__: Callable[[dict], Any] = None,\n    ):\n        emitter = EventEmitter(__event_emitter__)\n        metadata = {\"data\": {\"generated_by\": \"upload_file\"}}\n\n        await emitter.emit(f\"Getting download link for file: {file.filename}\")\n\n        # get the user for permissions\n        user = Users.get_user_by_id(id=__user__[\"id\"])\n        print(\"[DEBUG] user\", user)\n        # upload the file to the database\n        doc = upload_file(\n            request=__request__, file=file, user=user, metadata=metadata, process=False\n        )\n        print(\"[DEBUG] doc\", doc)\n\n        # get the download link\n        download_link = f\"{self.API_BASE_URL}{doc.id}/content\"\n        print(\"[DEBUG] download_link\", download_link)\n        await emitter.emit(\n            status=\"complete\",\n            description=f\"Finished generating the Excel file\",\n            done=True,\n        )\n        return (\n            f\"<source><source_id>{doc.filename}</source_id><source_context>\"\n            + str(download_link)\n            + \"</source_context></source>\\n\"\n        )\n","specs":[{"name":"generate_excel_from_json","description":"Generate an Excel document from a JSON file.\n\nArgs:\njson_data: The JSON data to generate the document from.\n__user__: The user to upload the file to.\nReturns:\nstr: The download URL of the uploaded file.\n\nExample:\nHere is an example of the JSON data for a complete Excel document:\n\n```json\n{\n\"titre\": \"Rapport financier\",\n\"feuilles\": [\n{\n\"nom\": \"Résumé\",\n\"tableau\": {\n\"colonnes\": [\"Mois\", \"Revenus\", \"Dépenses\", \"Profit\"],\n\"données\": [\n[\"Janvier\", 10000, 8000, 2000],\n[\"Février\", 12000, 7500, 4500],\n[\"Mars\", 15000, 9000, 6000]\n]\n}\n},\n{\n\"nom\": \"Détails dépenses\",\n\"tableau\": {\n\"colonnes\": [\"Catégorie\", \"Montant\", \"Pourcentage\"],\n\"données\": [\n[\"Salaires\", 5000, \"60%\"],\n[\"Loyer\", 1500, \"20%\"],\n[\"Fournitures\", 800, \"10%\"],\n[\"Marketing\", 500, \"5%\"],\n[\"Divers\", 400, \"5%\"]\n]\n}\n}\n]\n}\n```","parameters":{"properties":{"json_data":{"type":"object"}},"required":["json_data"],"type":"object"}},{"name":"upload_file","description":"","parameters":{"properties":{"file":{"format":"binary","type":"string"},"user_id":{"type":"string"}},"required":["file","user_id"],"type":"object"}}],"meta":{"description":"tool to generate excel files ( xlsx )","manifest":{"title":"Generate Excel Document","author":"openlab","version":"0.1","license":"MIT","description":"Génère un fichier Excel via un LLM (Ollama) et renvoie un lien de téléchargement"}},"access_control":{},"updated_at":1750756374,"created_at":1750751545},{"id":"generate_file","user_id":"5bfef5b3-563f-4ac3-a849-feeab72fbe46","name":"generate file","content":"\"\"\"\ntitle: Generate a file\nauthor: openlab\nversion: 0.1\nlicense: MIT\ndescription: allows to generate and give a download link\n\"\"\"\n\nimport os, uuid\nfrom pydantic import BaseModel, Field\nfrom open_webui.storage.provider import Storage\nfrom open_webui.models.files import Files\nfrom open_webui.models.files import FileForm\n\nfrom fastapi import UploadFile\n\n\nclass Tools:\n\n    def __init__(self):\n        self.API_BASE_URL = \"http://localhost:3000/api/v1/files/\"\n        self.API_KEY = \"sk-dcb0e2b13ee54211866423020dd9bf59\"\n        self.FILES_DIR = \"./tmp\"\n        self.TIMEOUT = 10\n\n    def create_file(\n        self,\n        file_name: str,\n        file_content: str,\n        file_extension: str = None,\n        __user__=None,\n    ):\n        \"\"\"\n        Create a file with the given name and content.\n        Handles different file extensions appropriately.\n        When you use this function make sure the always give to the user the link to download the file\n\n        Args:\n            file_name: Name of the file to create\n            file_content: Content to write to the file\n            file_extension: Optional extension to append if not already in file_name\n        Returns:\n            the download link of the file generated always send this to the user\n        \"\"\"\n\n        # If extension is provided and not already in file_name, append it\n        if file_extension and not file_name.endswith(f\".{file_extension}\"):\n            file_name = f\"{file_name}.{file_extension}\"\n\n        file_path = os.path.abspath(file_name)\n        if not os.path.exists(self.FILES_DIR):\n            os.makedirs(self.FILES_DIR)\n\n        # Determine if the file is binary or text based on extension\n        binary_extensions = [\"pdf\", \"png\", \"jpg\", \"jpeg\", \"gif\", \"zip\", \"exe\", \"bin\"]\n        is_binary = file_extension and file_extension.lower() in binary_extensions\n        file_path = os.path.join(self.FILES_DIR, file_name)\n        print(f\"[DEBUG] File path: {file_path}\")\n        # Write the file with appropriate mode\n        if is_binary:\n            # For binary files, content should be properly encoded\n            with open(file_path, \"wb\") as f:\n                # Assuming content might be base64 encoded for binary files\n                try:\n                    import base64\n\n                    f.write(base64.b64decode(file_content))\n                except:\n                    # Fallback if not base64 encoded\n                    f.write(file_content.encode(\"utf-8\"))\n        else:\n            # For text files\n            with open(file_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(file_content)\n        print(f\"[DEBUG] File created: {file_path}\")\n\n        # Upload the file to the OpenAI API\n        download_link = self.get_file_download_link(file_path, __user__)\n        return f\"This is the dowload link for the {file_name} : {download_link}\"\n\n    # Method to download a filde using the openwebui api.\n    def get_file_download_link(self, file: str, __user__=None):\n        \"\"\"\n        get the download link of a file\n        it utilise the openwebui api to upload the file and get the download link\n        ARGS:\n            file: the path to the file to upload\n        RETURNS:\n            the download link of the file\n        \"\"\"\n        try:\n            file_path = os.path.abspath(file)\n            print(f\"[DEBUG] File path: {file_path}\")\n            headers = {\n                \"accept\": \"application/json\",\n                \"Authorization\": f\"Bearer {self.API_KEY}\",\n            }\n            url = f\"{self.API_BASE_URL}\"  # Remove trailing slash\n            print(f\"[DEBUG] URL: {url}\")\n            print(f\"[DEBUG] Headers: {headers}\")\n\n            file_id = \"\"\n            try:\n                with open(file, \"rb\") as f:\n                    files = UploadFile(file=f, filename=os.path.basename(file))\n                    # files = {\"file\": f,\"filename\": os.path.basename(file),\"content_type\": \"application/octet-stream\"}\n                    print(f\"[DEBUG] Files: {files}\")\n                    # Use direct requests instead of self.post for more contro\n                    response = self.upload_file(files, __user__[\"id\"])\n                    print(f\"[DEBUG] Response: {response}\")\n\n                    # Parse the response\n                    file_id = response.id\n                    print(f\"[DEBUG] File ID: {file_id}\")\n                    if not file_id:\n                        return {\"error\": \"No file ID returned from upload\"}\n\n            except Exception as e:\n                print(f\"[DEBUG] Error uploading file: {str(e)}\")\n                return {\"error\": f\"Error uploading file: {str(e)}\"}\n\n            download_url = f\"{self.API_BASE_URL}{file_id}/content\"\n            print(f\"[DEBUG] Download URL: {download_url}\")\n            # delete the file from the local directory\n            # os.remove(file_path)\n            print(f\"[DEBUG] File {file_path} deleted\")\n            return download_url\n        except Exception as e:\n            # os.remove(file_path)\n            print(f\"[DEBUG] Error in download_file_openwebui: {str(e)}\")\n            return {\"error\": f\"Error in download_file_openwebui: {str(e)}\"}\n\n    def upload_file(self, file: UploadFile, user_id: str):\n        \"\"\"\n        upload a file to the openwebui data base without the API (API doesn't work with the tools in version 0.6.5)\n        ARGS:\n            file: the file to upload\n            user_id: the id of the user\n        RETURNS:\n            the file item\n        \"\"\"\n        filename = file.filename\n        id = str(uuid.uuid4())\n        name = filename\n        filename = f\"{id}_{filename}\"\n        contents, file_path = Storage.upload_file(file.file, filename)\n\n        file_item = Files.insert_new_file(\n            user_id,\n            FileForm(\n                **{\n                    \"id\": id,\n                    \"filename\": name,\n                    \"path\": file_path,\n                    \"meta\": {\n                        \"name\": name,\n                        \"content_type\": file.content_type,\n                        \"size\": len(contents),\n                        \"data\": {\"generated_by\": \"upload_file\"},\n                    },\n                }\n            ),\n        )\n        print(f\"[DEBUG] File item: {file_item}\")\n\n        return file_item\n","specs":[{"name":"create_file","description":"Create a file with the given name and content.\nHandles different file extensions appropriately.\nWhen you use this function make sure the always give to the user the link to download the file\n\nArgs:\nfile_name: Name of the file to create\nfile_content: Content to write to the file\nfile_extension: Optional extension to append if not already in file_name\nReturns:\nthe download link of the file generated always send this to the user","parameters":{"properties":{"file_name":{"type":"string"},"file_content":{"type":"string"},"file_extension":{"default":null,"type":"string"}},"required":["file_name","file_content"],"type":"object"}},{"name":"get_file_download_link","description":"get the download link of a file\nit utilise the openwebui api to upload the file and get the download link\nARGS:\nfile: the path to the file to upload\nRETURNS:\nthe download link of the file","parameters":{"properties":{"file":{"type":"string"}},"required":["file"],"type":"object"}},{"name":"upload_file","description":"upload a file to the openwebui data base without the API (API doesn't work with the tools in version 0.6.5)\nARGS:\nfile: the file to upload\nuser_id: the id of the user\nRETURNS:\nthe file item","parameters":{"properties":{"file":{"format":"binary","type":"string"},"user_id":{"type":"string"}},"required":["file","user_id"],"type":"object"}}],"meta":{"description":"Generates files then provide the download url ","manifest":{"title":"Generate a file","author":"openlab","version":"0.1","license":"MIT","description":"allows to generate and give a download link"}},"access_control":{},"updated_at":1750756007,"created_at":1750751545},{"id":"generate_pptx_file_","user_id":"5bfef5b3-563f-4ac3-a849-feeab72fbe46","name":"generate pptx file ","content":"\"\"\"\ntitle: Generate PPTX Presentation\nauthor: openlab\nversion: 0.1\nlicense: MIT\ndescription: Génère un fichier PPTX via un LLM (Ollama) et renvoie un lien de téléchargement\n\"\"\"\n\nimport os, uuid, tempfile\nfrom typing import Optional\nfrom pathlib import Path\nfrom fastapi import UploadFile\nimport re\nimport json\nfrom datetime import datetime\nfrom pptx import Presentation\nfrom pptx.oxml.xmlchemy import OxmlElement\nfrom pptx.util import Inches\n\nfrom open_webui.routers.files import upload_file\nfrom open_webui.models.users import Users\nfrom fastapi import Request\nfrom open_webui.storage.provider import Storage\nfrom open_webui.models.files import Files, FileForm\nfrom typing import Callable, Any\n\n\nclass EventEmitter:\n    def __init__(self, event_emitter: Callable[[dict], Any] = None):\n        self.event_emitter = event_emitter\n\n    async def emit(self, description=\"Unknown State\", status=\"in_progress\", done=False):\n        if self.event_emitter:\n            await self.event_emitter(\n                {\n                    \"type\": \"status\",\n                    \"data\": {\n                        \"status\": status,\n                        \"description\": description,\n                        \"done\": done,\n                    },\n                }\n            )\n\n\nclass HelpFunctions:\n    def __init__(self):\n\n        self.slide_layouts = {\n            \"title_and_content\": 1,\n            \"abstract\": 2,\n            \"chapter_title\": 3,\n            \"basic_content\": 4,\n            \"final_slide_fr\": 12,\n            \"final_slide_en\": 13,\n        }\n\n    def remove_tags_no_keep(self, text: str, start: str, end: str) -> str:\n        \"\"\"\n        Remove all text between two tags (`start` and `end`), tags included.\n\n        Parameters\n        ----------\n        text : str\n            text to remove tags from\n        start : str\n            starting tag\n        end : str\n            ending tag\n\n        Returns\n        -------\n        str\n            Text with tags removed\n        \"\"\"\n        return re.sub(r\"{}.*?{}\".format(start, end), \"\", text, flags=re.DOTALL).strip()\n\n    def SubElement(self, parent, tagname, **kwargs):\n        \"\"\"\n        Helper for Paragraph bullet Point\n        \"\"\"\n        element = OxmlElement(tagname)\n        element.attrib.update(kwargs)\n        parent.append(element)\n        return element\n\n    def getBulletInfo(self, paragraph, run=None):\n        \"\"\"\n        Returns the attributes of the given <a:pPr> OxmlElement\n        as well as its runs font-size.\n\n        *param: paragraph* pptx _paragraph object\n        *param: run* [optional] specific _run object\n        \"\"\"\n        pPr = paragraph._p.get_or_add_pPr()\n        if run is None:\n            run = paragraph.runs[0]\n        p_info = {\n            \"level\": paragraph.level,\n            \"fontName\": run.font.name,\n            \"fontSize\": run.font.size,\n        }\n        return p_info\n\n    def pBullet(\n        self,\n        paragraph,  # paragraph object\n        font,  # fontName of that needs to be applied to bullet\n        marL: int = 864000,\n        indent: int = -322920,\n        size: int = 350000,  # fontSize (in )\n    ):\n        \"\"\"Bullets are set to Arial,\n        actual text can be a different font\n        \"\"\"\n        pPr = paragraph._p.get_or_add_pPr()\n        # Set marL and indent attributes\n        # Indent is the space between the bullet and the text.\n        pPr.set(\"marL\", str(marL))\n        pPr.set(\"indent\", str(indent))\n        # Add buFont\n        _ = self.SubElement(parent=pPr, tagname=\"a:buSzPct\", val=str(size))\n        _ = self.SubElement(\n            parent=pPr,\n            tagname=\"a:buFont\",\n            typeface=font,\n        )\n        # Add buChar\n        _ = self.SubElement(parent=pPr, tagname=\"a:buChar\", char=\"•\")\n\n    def upload_file(self, file: UploadFile, user_id: str):\n        \"\"\"\n        upload a file to the openwebui data base without the API (API doesn't work with the tools in version 0.6.5)\n        ARGS:\n            file: the file to upload\n            user_id: the id of the user\n        RETURNS:\n            the file item\n        \"\"\"\n        filename = file.filename\n        id = str(uuid.uuid4())\n        name = filename\n        filename = f\"{id}_{filename}\"\n        contents, file_path = Storage.upload_file(file.file, filename)\n\n        file_item = Files.insert_new_file(\n            user_id,\n            FileForm(\n                **{\n                    \"id\": id,\n                    \"filename\": name,\n                    \"path\": file_path,\n                    \"meta\": {\n                        \"name\": name,\n                        \"content_type\": file.content_type,\n                        \"size\": len(contents),\n                        \"data\": {\"generated_by\": \"upload_file\"},\n                    },\n                }\n            ),\n        )\n        print(f\"[DEBUG] File item: {file_item}\")\n\n        return file_item\n\n    def add_title_slide(\n        self, prs: Presentation, title: str = \"Title\", author: str = \"author\"\n    ) -> None:\n        \"\"\"\n        Creates and adds a new title slide to the given PowerPoint presentation.\n\n        Args:\n            prs (Presentation): The PowerPoint presentation object.\n            title (str, optional): The title of the slide. Defaults to \"Title\".\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If the provided title is empty.\n        \"\"\"\n\n        # Check if the title is not empty\n        if not title.strip():\n            raise ValueError(\"Slide title cannot be empty.\")\n        # Create new title slide\n        slide_layout = prs.slide_layouts[self.slide_layouts[\"title_and_content\"]]\n        slide = prs.slides.add_slide(slide_layout)\n\n        # fill in the content\n        slide.shapes[0].text = title\n        # add the author\n        slide.shapes[1].text = author\n        # add the date\n        slide.shapes[3].text = datetime.now().strftime(\"%d/%m/%Y\")\n\n    def add_chapter_slide(\n        self, prs: Presentation, chapter: str = \"Title\", suptitle: Optional[str] = None\n    ) -> None:\n        \"\"\"\n        Adds a new chapter title slide to a PowerPoint presentation.\n\n        Args:\n            prs (Presentation): The presentation object.\n            chapter (str): The main title of the slide. Defaults to \"Title\".\n            suptitle (str, optional): The suptitle of the slide. Defaults to None.\n\n        Raises:\n            ValueError: If the title is empty.\n\n        Returns:\n            None\n        \"\"\"\n        # Check if the title is not empty\n        if not chapter.strip():\n            raise ValueError(\"Slide title cannot be empty.\")\n        # Create new title slide\n        slide_layout = prs.slide_layouts[self.slide_layouts[\"chapter_title\"]]\n        slide = prs.slides.add_slide(slide_layout)\n\n        # fill in the content\n        slide.shapes[0].text = chapter\n        if suptitle is not None and suptitle.strip():\n            slide.shapes[1].text = suptitle\n\n    def add_content_slide(\n        self, prs: Presentation, title: str = \"Title\", content: str = \"Content\"\n    ) -> None:\n        \"\"\"\n        Adds a new title and content slide to the presentation.\n\n        Args:\n            prs (Presentation): The presentation object.\n            title (str): The title of the slide. Defaults to \"Title\".\n            content (str): The content of the slide. Defaults to \"Content\".\n\n        Raises:\n            ValueError: If the title or content is empty.\n        \"\"\"\n        # Check if the title is not empty\n        if not title.strip():\n            raise ValueError(\"Slide title cannot be empty.\")\n        if not content.strip():\n            raise ValueError(\"Slide content cannot be empty.\")\n        # Create new title slide\n        slide_layout = prs.slide_layouts[self.slide_layouts[\"basic_content\"]]\n        slide = prs.slides.add_slide(slide_layout)\n\n        # fill in the content\n        slide.shapes[0].text = title\n        body_shape = slide.shapes.placeholders[1]\n\n        tf = body_shape.text_frame\n        lines = content.split(\"\\n\")\n        for line in lines:\n            p = tf.add_paragraph()\n            p.level = 0\n            need_bullet = False\n            spacing = 0\n            while line.startswith(\"    \"):\n                line = line[4:]\n                spacing += 1\n            if line.startswith(\"* \") or line.startswith(\"• \"):\n                need_bullet = True\n                line = line[2:]\n            if need_bullet:\n                p.text = line\n                p.level = spacing + 1\n                # For some reason, level 2 is dumb.\n                # Should patch this in the template, but well ...\n                if p.level >= 2:\n                    p.level += 1\n\n                print(self.getBulletInfo(p))\n                # pBullet(p, \"Arial\", marL=p.level*864000, size=100000)\n            else:\n                p.text = \"   \" * spacing + line\n\n    def add_final_slide(self, prs: Presentation, language: str) -> None:\n        \"\"\"\n        Adds a final slide to the presentation.\n        \"\"\"\n        if language == \"fr\":\n            slide_layout = prs.slide_layouts[self.slide_layouts[\"final_slide_fr\"]]\n        else:\n            slide_layout = prs.slide_layouts[self.slide_layouts[\"final_slide_en\"]]\n        slide = prs.slides.add_slide(slide_layout)\n\n\n# --- Tools ---\nclass Tools:\n    def __init__(self):\n        \"\"\"faire le truc avec le JSON\"\"\"\n        self.FILES_DIR = \"./tmp\"\n        self.API_BASE_URL = \"http://localhost:3000/api/v1/files/\"\n        # templates paths\n        self.base_template_path = \"./\"\n        self.fr_dir = \"./\"\n        self.en_dir = \"./\"\n\n        self.prefix = \"CS-\"\n        os.makedirs(self.FILES_DIR, exist_ok=True)\n        self.help_functions = HelpFunctions()\n        self.event_emitter = EventEmitter()\n\n    async def generate_pptx_from_json(\n        self,\n        language: str,\n        confidentiality: str,\n        json_data: dict,\n        __request__: Request,\n        __event_emitter__: Callable[[dict], Any] = None,\n        __user__=None,\n    ):\n        \"\"\"\n        Generate a PowerPoint presentation from a JSON file.\n\n        Args:\n            language : The language of the presentation. (fr or en)\n            confidentiality : The confidentiality of the presentation.\n            json_data : The JSON data to generate the presentation from.\n            __user__ : The user to upload the file to.\n        Returns:\n            str: The download URL of the uploaded file.\n\n        Example:\n        Here is an example of the JSON data:\n\n        ```json\n            {\n                \"titre\": \"Titre de la présentation\",\n                \"slides\": [\n                    {\n                        \"type\": \"titre\",\n                        \"titre\": \"Titre de la présentation\"\n                    },\n                    {\n                        \"type\": \"chapitre\",\n                        \"titre\": \"Titre du chapitre\"\n                    },\n                    {\n                        \"type\": \"contenu\",\n                        \"titre\": \"Titre du chapitre\",\n                        \"contenu\": \"Contenu de la slide\\n* Bullet list\\n.   * Bullet list niveau 2\"\n                    }\n                ]\n            }\n        ```\n        \"\"\"\n        emitter = EventEmitter(__event_emitter__)\n        print(\"[DEBUG] json_data\", json_data)\n        # json_data = json.loads(json_data)\n        # print(\"[DEBUG] json loaded\", json_data)\n        topic = json_data.get(\"titre\")\n        print(\"[DEBUG] topic\", topic)\n        await emitter.emit(f\"Initiating pptx generation for topic: {topic}\")\n\n        # Load JSON data\n        print(\"[DEBUG] json_formatted\", json_data)\n        print(\"[DEBUG] language\", language)\n        print(\"[DEBUG] confidentiality\", confidentiality)\n        if confidentiality == \"public\":\n            self.prefix = \"CS-PU-\"\n        elif confidentiality == \"internal\":\n            self.prefix = \"CS-IN-\"\n        else:\n            self.prefix = \"CS-CO-\"\n\n        # Create presentation\n        if language == \"fr\" or language == \"french\":\n            # generating the template path french\n            template_path = (\n                self.base_template_path + self.fr_dir + self.prefix + \"template_fr.pptx\"\n            )\n            print(\"[DEBUG] french template path\", template_path)\n            prs = Presentation(template_path)\n        else:\n            # generating the template path english\n            template_path = (\n                self.base_template_path + self.en_dir + self.prefix + \"template_en.pptx\"\n            )\n            print(\"[DEBUG] english template path\", template_path)\n            prs = Presentation(template_path)\n\n        print(\"[DEBUG] prs\", prs)\n        # Add title slide\n        self.help_functions.add_title_slide(\n            prs, title=json_data[\"titre\"], author=__user__[\"name\"]\n        )\n        print(\"[DEBUG] title slide added\")\n        print(\"[DEBUG] user\", __user__)\n\n        # Add content slides\n        try:\n            await emitter.emit(\"Creating slides\")\n            for slide in json_data[\"slides\"]:\n                print(\"[DEBUG] slide\", slide)\n                if slide[\"type\"] == \"chapitre\":\n                    self.help_functions.add_chapter_slide(prs, chapter=slide[\"titre\"])\n                    print(\"[DEBUG] chapter slide added\")\n                elif slide[\"type\"] == \"contenu\":\n                    self.help_functions.add_content_slide(\n                        prs, title=slide[\"titre\"], content=slide[\"contenu\"]\n                    )\n                    print(\"[DEBUG] content slide added\")\n            # add the final slide at the end of the presentation\n            self.help_functions.add_final_slide(prs, language=language)\n\n            await emitter.emit(\n                status=\"complete\",\n                description=f\"PPTX generation completed\",\n                done=True,\n            )\n        except Exception as e:\n            print(\"[DEBUG] Error\", e)\n            return \"Error\"\n\n        # Save presentation\n        if not os.path.exists(self.FILES_DIR):\n            os.makedirs(self.FILES_DIR)\n        # change the spaces to _\n        json_data[\"titre\"] = json_data[\"titre\"]\n        # remove all special characters\n        json_data[\"titre\"] = re.sub(r\"[^\\w\\s]\", \"\", json_data[\"titre\"])\n        # remove all spaces\n        json_data[\"titre\"] = json_data[\"titre\"].replace(\" \", \"_\")\n\n        output_path = self.FILES_DIR + \"/\" + self.prefix + json_data[\"titre\"] + \".pptx\"\n        prs.save(output_path)\n        print(\"[DEBUG] output_path\", output_path)\n\n        try:\n            with open(output_path, \"rb\") as f:\n                print(\"[DEBUG] f\", f)\n                files = UploadFile(file=f, filename=os.path.basename(output_path))\n                print(\"[DEBUG] files\", files)\n                file_item = await self.upload_file(\n                    file=files,\n                    user_id=__user__[\"id\"],\n                    __request__=__request__,\n                    __user__=__user__,\n                    __event_emitter__=__event_emitter__,\n                )\n                print(\"[DEBUG] file_item\", file_item)\n                return file_item\n        except Exception as e:\n            print(\"[DEBUG] Error\", e)\n            return \"Error\"\n\n    async def upload_file(\n        self,\n        file: UploadFile,\n        user_id: str,\n        __request__: Request,\n        __user__: dict,\n        __event_emitter__: Callable[[dict], Any] = None,\n    ):\n\n        emitter = EventEmitter(__event_emitter__)\n        metadata = {\"data\": {\"generated_by\": \"upload_file\"}}\n\n        await emitter.emit(f\"getting download link for file : {file.filename}\")\n\n        # get the user for permissions\n        user = Users.get_user_by_id(id=__user__[\"id\"])\n        print(\"[DEBUG] user\", user)\n        # upload the file to the database\n        doc = upload_file(\n            request=__request__, file=file, user=user, metadata=metadata, process=False\n        )\n        print(\"[DEBUG] doc\", doc)\n\n        # get the download link\n        download_link = f\"{self.API_BASE_URL}{doc.id}/content\"\n        print(\"[DEBUG] download_link\", download_link)\n        await emitter.emit(\n            status=\"complete\",\n            description=f\"finished generating the pptx file\",\n            done=True,\n        )\n        return (\n            f\"<source><source_id>{doc.filename}</source_id><source_context>\"\n            + str(download_link)\n            + \"</source_context></source>\\n\"\n        )\n","specs":[{"name":"generate_pptx_from_json","description":"Generate a PowerPoint presentation from a JSON file.\n\nArgs:\nlanguage : The language of the presentation. (fr or en)\nconfidentiality : The confidentiality of the presentation.\njson_data : The JSON data to generate the presentation from.\n__user__ : The user to upload the file to.\nReturns:\nstr: The download URL of the uploaded file.\n\nExample:\nHere is an example of the JSON data:\n\n```json\n{\n\"titre\": \"Titre de la présentation\",\n\"slides\": [\n{\n\"type\": \"titre\",\n\"titre\": \"Titre de la présentation\"\n},\n{\n\"type\": \"chapitre\",\n\"titre\": \"Titre du chapitre\"\n},\n{\n\"type\": \"contenu\",\n\"titre\": \"Titre du chapitre\",\n\"contenu\": \"Contenu de la slide\n* Bullet list\n.   * Bullet list niveau 2\"\n}\n]\n}\n```","parameters":{"properties":{"language":{"type":"string"},"confidentiality":{"type":"string"},"json_data":{"type":"object"}},"required":["language","confidentiality","json_data"],"type":"object"}},{"name":"upload_file","description":"","parameters":{"properties":{"file":{"format":"binary","type":"string"},"user_id":{"type":"string"}},"required":["file","user_id"],"type":"object"}}],"meta":{"description":"tool to generate pptx file ","manifest":{"title":"Generate PPTX Presentation","author":"openlab","version":"0.1","license":"MIT","description":"Génère un fichier PPTX via un LLM (Ollama) et renvoie un lien de téléchargement"}},"access_control":{},"updated_at":1750753902,"created_at":1750751545}]