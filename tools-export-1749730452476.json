[{"id":"generate_pptx_file_","user_id":"1f81ea87-3e74-4b85-a8ab-ca07d71d9ec0","name":"generate pptx file ","content":"\"\"\"\ntitle: Generate PPTX Presentation\nauthor: openlab\nversion: 0.1\nlicense: MIT\ndescription: Génère un fichier PPTX via un LLM (Ollama) et renvoie un lien de téléchargement\n\"\"\"\n\nimport os, uuid, tempfile\nfrom typing import Optional\nfrom pathlib import Path\nfrom fastapi import UploadFile\nimport re\nimport json\nfrom pptx import Presentation\nfrom pptx.oxml.xmlchemy import OxmlElement\nfrom pptx.util import Inches\n\nfrom open_webui.routers.files import upload_file\nfrom open_webui.models.users import Users\nfrom fastapi import Request\nfrom open_webui.storage.provider import Storage\nfrom open_webui.models.files import Files, FileForm\nfrom typing import Callable, Any\n\n\nclass EventEmitter:\n    def __init__(self, event_emitter: Callable[[dict], Any] = None):\n        self.event_emitter = event_emitter\n\n    async def emit(self, description=\"Unknown State\", status=\"in_progress\", done=False):\n        if self.event_emitter:\n            await self.event_emitter(\n                {\n                    \"type\": \"status\",\n                    \"data\": {\n                        \"status\": status,\n                        \"description\": description,\n                        \"done\": done,\n                    },\n                }\n            )\n\n\nclass HelpFunctions:\n    def __init__(self):\n\n        self.slide_layouts = {\n            \"title_and_content\": 1,\n            \"title_with_a_image\": 2,\n            \"abstract\": 3,\n            \"chapter_title\": 4,\n            \"basic_content\": 5,\n        }\n\n    def remove_tags_no_keep(self, text: str, start: str, end: str) -> str:\n        \"\"\"\n        Remove all text between two tags (`start` and `end`), tags included.\n\n        Parameters\n        ----------\n        text : str\n            text to remove tags from\n        start : str\n            starting tag\n        end : str\n            ending tag\n\n        Returns\n        -------\n        str\n            Text with tags removed\n        \"\"\"\n        return re.sub(r\"{}.*?{}\".format(start, end), \"\", text, flags=re.DOTALL).strip()\n\n    def SubElement(self, parent, tagname, **kwargs):\n        \"\"\"\n        Helper for Paragraph bullet Point\n        \"\"\"\n        element = OxmlElement(tagname)\n        element.attrib.update(kwargs)\n        parent.append(element)\n        return element\n\n    def getBulletInfo(self, paragraph, run=None):\n        \"\"\"\n        Returns the attributes of the given <a:pPr> OxmlElement\n        as well as its runs font-size.\n\n        *param: paragraph* pptx _paragraph object\n        *param: run* [optional] specific _run object\n        \"\"\"\n        pPr = paragraph._p.get_or_add_pPr()\n        if run is None:\n            run = paragraph.runs[0]\n        p_info = {\n            \"level\": paragraph.level,\n            \"fontName\": run.font.name,\n            \"fontSize\": run.font.size,\n        }\n        return p_info\n\n    def pBullet(\n        self,\n        paragraph,  # paragraph object\n        font,  # fontName of that needs to be applied to bullet\n        marL: int = 864000,\n        indent: int = -322920,\n        size: int = 350000,  # fontSize (in )\n    ):\n        \"\"\"Bullets are set to Arial,\n        actual text can be a different font\n        \"\"\"\n        pPr = paragraph._p.get_or_add_pPr()\n        # Set marL and indent attributes\n        # Indent is the space between the bullet and the text.\n        pPr.set(\"marL\", str(marL))\n        pPr.set(\"indent\", str(indent))\n        # Add buFont\n        _ = self.SubElement(parent=pPr, tagname=\"a:buSzPct\", val=str(size))\n        _ = self.SubElement(\n            parent=pPr,\n            tagname=\"a:buFont\",\n            typeface=font,\n        )\n        # Add buChar\n        _ = self.SubElement(parent=pPr, tagname=\"a:buChar\", char=\"•\")\n\n    def upload_file(self, file: UploadFile, user_id: str):\n        \"\"\"\n        upload a file to the openwebui data base without the API (API doesn't work with the tools in version 0.6.5)\n        ARGS:\n            file: the file to upload\n            user_id: the id of the user\n        RETURNS:\n            the file item\n        \"\"\"\n        filename = file.filename\n        id = str(uuid.uuid4())\n        name = filename\n        filename = f\"{id}_{filename}\"\n        contents, file_path = Storage.upload_file(file.file, filename)\n\n        file_item = Files.insert_new_file(\n            user_id,\n            FileForm(\n                **{\n                    \"id\": id,\n                    \"filename\": name,\n                    \"path\": file_path,\n                    \"meta\": {\n                        \"name\": name,\n                        \"content_type\": file.content_type,\n                        \"size\": len(contents),\n                        \"data\": {\"generated_by\": \"upload_file\"},\n                    },\n                }\n            ),\n        )\n        print(f\"[DEBUG] File item: {file_item}\")\n\n        return file_item\n\n    def add_title_slide(self, prs: Presentation, title: str = \"Title\") -> None:\n        \"\"\"\n        Creates and adds a new title slide to the given PowerPoint presentation.\n\n        Args:\n            prs (Presentation): The PowerPoint presentation object.\n            title (str, optional): The title of the slide. Defaults to \"Title\".\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If the provided title is empty.\n        \"\"\"\n\n        # Check if the title is not empty\n        if not title.strip():\n            raise ValueError(\"Slide title cannot be empty.\")\n        # Create new title slide\n        slide_layout = prs.slide_layouts[self.slide_layouts[\"title_and_content\"]]\n        slide = prs.slides.add_slide(slide_layout)\n\n        # fill in the content\n        slide.shapes[0].text = title\n\n    def add_chapter_slide(\n        self, prs: Presentation, chapter: str = \"Title\", suptitle: Optional[str] = None\n    ) -> None:\n        \"\"\"\n        Adds a new chapter title slide to a PowerPoint presentation.\n\n        Args:\n            prs (Presentation): The presentation object.\n            chapter (str): The main title of the slide. Defaults to \"Title\".\n            suptitle (str, optional): The suptitle of the slide. Defaults to None.\n\n        Raises:\n            ValueError: If the title is empty.\n\n        Returns:\n            None\n        \"\"\"\n        # Check if the title is not empty\n        if not chapter.strip():\n            raise ValueError(\"Slide title cannot be empty.\")\n        # Create new title slide\n        slide_layout = prs.slide_layouts[self.slide_layouts[\"chapter_title\"]]\n        slide = prs.slides.add_slide(slide_layout)\n\n        # fill in the content\n        slide.shapes[0].text = chapter\n        if suptitle is not None and suptitle.strip():\n            slide.shapes[1].text = suptitle\n\n    def add_content_slide(\n        self, prs: Presentation, title: str = \"Title\", content: str = \"Content\"\n    ) -> None:\n        \"\"\"\n        Adds a new title and content slide to the presentation.\n\n        Args:\n            prs (Presentation): The presentation object.\n            title (str): The title of the slide. Defaults to \"Title\".\n            content (str): The content of the slide. Defaults to \"Content\".\n\n        Raises:\n            ValueError: If the title or content is empty.\n        \"\"\"\n        # Check if the title is not empty\n        if not title.strip():\n            raise ValueError(\"Slide title cannot be empty.\")\n        if not content.strip():\n            raise ValueError(\"Slide content cannot be empty.\")\n        # Create new title slide\n        slide_layout = prs.slide_layouts[self.slide_layouts[\"basic_content\"]]\n        slide = prs.slides.add_slide(slide_layout)\n\n        # fill in the content\n        slide.shapes[0].text = title\n        body_shape = slide.shapes.placeholders[1]\n\n        tf = body_shape.text_frame\n        lines = content.split(\"\\n\")\n        for line in lines:\n            p = tf.add_paragraph()\n            p.level = 0\n            need_bullet = False\n            spacing = 0\n            while line.startswith(\"    \"):\n                line = line[4:]\n                spacing += 1\n            if line.startswith(\"* \") or line.startswith(\"• \"):\n                need_bullet = True\n                line = line[2:]\n            if need_bullet:\n                p.text = line\n                p.level = spacing + 1\n                # For some reason, level 2 is dumb.\n                # Should patch this in the template, but well ...\n                if p.level >= 2:\n                    p.level += 1\n\n                print(self.getBulletInfo(p))\n                # pBullet(p, \"Arial\", marL=p.level*864000, size=100000)\n            else:\n                p.text = \"   \" * spacing + line\n\n\n# --- Tools ---\nclass Tools:\n    def __init__(self):\n        \"\"\"faire le truc avec le JSON\"\"\"\n        self.FILES_DIR = \"./tmp\"\n        self.API_BASE_URL = \"http://localhost:8080/api/v1/files/\"\n        self.template_path = \"./templates/template.pptx\"\n        os.makedirs(self.FILES_DIR, exist_ok=True)\n        self.help_functions = HelpFunctions()\n        self.event_emitter = EventEmitter()\n\n    async def generate_pptx_from_json(\n        self,\n        json_data: dict,\n        __request__: Request,\n        __event_emitter__: Callable[[dict], Any] = None,\n        __user__=None,\n    ):\n        \"\"\"\n        Generate a PowerPoint presentation from a JSON file.\n\n        Args:\n            json_data : The JSON data to generate the presentation from.\n            __user__ : The user to upload the file to.\n        Returns:\n            str: The download URL of the uploaded file.\n\n        Example:\n        Here is an example of the JSON data:\n\n        ```json\n            {\n                \"titre\": \"Titre de la présentation\",\n                \"slides\": [\n                    {\n                        \"type\": \"titre\",\n                        \"titre\": \"Titre de la présentation\"\n                    },\n                    {\n                        \"type\": \"chapitre\",\n                        \"titre\": \"Titre du chapitre\"\n                    },\n                    {\n                        \"type\": \"contenu\",\n                        \"titre\": \"Titre du chapitre\",\n                        \"contenu\": \"Contenu de la slide\\n* Bullet list\\n.   * Bullet list niveau 2\"\n                    }\n                ]\n            }\n        ```\n        \"\"\"\n        emitter = EventEmitter(__event_emitter__)\n        print(\"[DEBUG] json_data\", json_data)\n        # json_data = json.loads(json_data)\n        # print(\"[DEBUG] json loaded\", json_data)\n        topic = json_data.get(\"titre\")\n        print(\"[DEBUG] topic\", topic)\n        await emitter.emit(f\"Initiating pptx generation for topic: {topic}\")\n\n        # Load JSON data\n        print(\"[DEBUG] json_formatted\", json_data)\n\n        # Create presentation\n        prs = Presentation(self.template_path)\n        print(\"[DEBUG] prs\", prs)\n\n        # Add title slide\n        self.help_functions.add_title_slide(prs, title=json_data[\"titre\"])\n        print(\"[DEBUG] title slide added\")\n\n        # Add content slides\n        try:\n            await emitter.emit(\"Creating slides\")\n            for slide in json_data[\"slides\"]:\n                print(\"[DEBUG] slide\", slide)\n                if slide[\"type\"] == \"chapitre\":\n                    self.help_functions.add_chapter_slide(prs, chapter=slide[\"titre\"])\n                    print(\"[DEBUG] chapter slide added\")\n                elif slide[\"type\"] == \"contenu\":\n                    self.help_functions.add_content_slide(\n                        prs, title=slide[\"titre\"], content=slide[\"contenu\"]\n                    )\n                    print(\"[DEBUG] content slide added\")\n            await emitter.emit(\n                status=\"complete\",\n                description=f\"PPTX generation completed\",\n                done=True,\n            )\n        except Exception as e:\n            print(\"[DEBUG] Error\", e)\n            return \"Error\"\n\n        # Save presentation\n        if not os.path.exists(self.FILES_DIR):\n            os.makedirs(self.FILES_DIR)\n        # change the spaces to _\n        json_data[\"titre\"] = json_data[\"titre\"]\n        # remove all special characters\n        json_data[\"titre\"] = re.sub(r\"[^\\w\\s]\", \"\", json_data[\"titre\"])\n        # remove all spaces\n        json_data[\"titre\"] = json_data[\"titre\"].replace(\" \", \"_\")\n\n        output_path = self.FILES_DIR + \"/\" + json_data[\"titre\"] + \".pptx\"\n        prs.save(output_path)\n        print(\"[DEBUG] output_path\", output_path)\n\n        try:\n            with open(output_path, \"rb\") as f:\n                print(\"[DEBUG] f\", f)\n                files = UploadFile(file=f, filename=os.path.basename(output_path))\n                print(\"[DEBUG] files\", files)\n                file_item = await self.upload_file(\n                    file=files,\n                    user_id=__user__[\"id\"],\n                    __request__=__request__,\n                    __user__=__user__,\n                    __event_emitter__=__event_emitter__,\n                )\n                print(\"[DEBUG] file_item\", file_item)\n                return file_item\n        except Exception as e:\n            print(\"[DEBUG] Error\", e)\n            return \"Error\"\n\n    async def upload_file(\n        self,\n        file: UploadFile,\n        user_id: str,\n        __request__: Request,\n        __user__: dict,\n        __event_emitter__: Callable[[dict], Any] = None,\n    ):\n\n        emitter = EventEmitter(__event_emitter__)\n        metadata = {\"data\": {\"generated_by\": \"upload_file\"}}\n\n        await emitter.emit(f\"getting download link for file : {file.filename}\")\n\n        # get the user for permissions\n        user = Users.get_user_by_id(id=__user__[\"id\"])\n        print(\"[DEBUG] user\", user)\n        # upload the file to the database\n        doc = upload_file(\n            request=__request__,\n            file=file,\n            user=user,\n            file_metadata=metadata,\n            process=False,\n        )\n        print(\"[DEBUG] doc\", doc)\n\n        # get the download link\n        download_link = f\"{self.API_BASE_URL}{doc.id}/content\"\n        print(\"[DEBUG] download_link\", download_link)\n        await emitter.emit(\n            status=\"complete\",\n            description=f\"finished generating the pptx file\",\n            done=True,\n        )\n        return (\n            f\"<source><source_id>{doc.filename}</source_id><source_context>\"\n            + str(download_link)\n            + \"</source_context></source>\\n\"\n        )\n","specs":[{"name":"generate_pptx_from_json","description":"","parameters":{"properties":{"json_data":{"type":"object"}},"required":["json_data"],"type":"object"}},{"name":"upload_file","description":"","parameters":{"properties":{"file":{"format":"binary","type":"string"},"user_id":{"type":"string"}},"required":["file","user_id"],"type":"object"}}],"meta":{"description":"tool to generate pptx file ","manifest":{"title":"Generate PPTX Presentation","author":"openlab","version":"0.1","license":"MIT","description":"Génère un fichier PPTX via un LLM (Ollama) et renvoie un lien de téléchargement"}},"access_control":{},"updated_at":1747298439,"created_at":1747037974},{"id":"generate_excel_files","user_id":"1f81ea87-3e74-4b85-a8ab-ca07d71d9ec0","name":"generate excel files","content":"\"\"\"\ntitle: Generate Excel Document\nauthor: openlab\nversion: 0.1\nlicense: MIT\ndescription: Génère un fichier Excel via un LLM (Ollama) et renvoie un lien de téléchargement\n\"\"\"\n\nimport os, uuid\nfrom typing import Optional, Callable, Any, List, Dict\nfrom pathlib import Path\nfrom fastapi import UploadFile, Request\nimport re\nimport json\nfrom openpyxl import Workbook\nfrom openpyxl.styles import Font, Alignment, PatternFill, Border, Side\nfrom openpyxl.utils import get_column_letter\nfrom openpyxl.worksheet.table import Table, TableStyleInfo\n\nfrom open_webui.routers.files import upload_file\nfrom open_webui.models.users import Users\nfrom open_webui.storage.provider import Storage\nfrom open_webui.models.files import Files, FileForm\n\n\nclass EventEmitter:\n    def __init__(self, event_emitter: Callable[[dict], Any] = None):\n        self.event_emitter = event_emitter\n\n    async def emit(self, description=\"Unknown State\", status=\"in_progress\", done=False):\n        if self.event_emitter:\n            await self.event_emitter(\n                {\n                    \"type\": \"status\",\n                    \"data\": {\n                        \"status\": status,\n                        \"description\": description,\n                        \"done\": done,\n                    },\n                }\n            )\n\n\nclass HelpFunctions:\n    def __init__(self):\n        self.default_fonts = {\n            \"main\": \"Calibri\",\n            \"header\": \"Arial\",\n        }\n        self.colors = {\"header_bg\": \"1F4E78\", \"alt_row\": \"F2F2F2\", \"grid\": \"D3D3D3\"}\n\n    def format_header_row(self, worksheet, row_num, columns):\n        \"\"\"\n        Format the header row with styling.\n\n        Args:\n            worksheet: The Excel worksheet.\n            row_num (int): The row number for the header.\n            columns (list): List of column names.\n        \"\"\"\n        # Define styles\n        header_font = Font(name=self.default_fonts[\"header\"], bold=True, color=\"FFFFFF\")\n        header_fill = PatternFill(\n            start_color=self.colors[\"header_bg\"],\n            end_color=self.colors[\"header_bg\"],\n            fill_type=\"solid\",\n        )\n        header_alignment = Alignment(\n            horizontal=\"center\", vertical=\"center\", wrap_text=True\n        )\n\n        # Apply styles to header row\n        for col_idx, column_name in enumerate(columns, 1):\n            cell = worksheet.cell(row=row_num, column=col_idx)\n            cell.value = column_name\n            cell.font = header_font\n            cell.fill = header_fill\n            cell.alignment = header_alignment\n\n            # Adjust column width based on content\n            column_letter = get_column_letter(col_idx)\n            worksheet.column_dimensions[column_letter].width = max(\n                12, len(column_name) + 2\n            )\n\n    def format_data_rows(self, worksheet, start_row, end_row, num_cols):\n        \"\"\"\n        Format the data rows with alternating colors and borders.\n\n        Args:\n            worksheet: The Excel worksheet.\n            start_row (int): Starting row number for data.\n            end_row (int): Ending row number for data.\n            num_cols (int): Number of columns.\n        \"\"\"\n        # Define styles\n        alt_fill = PatternFill(\n            start_color=self.colors[\"alt_row\"],\n            end_color=self.colors[\"alt_row\"],\n            fill_type=\"solid\",\n        )\n        thin_border = Border(\n            left=Side(style=\"thin\", color=self.colors[\"grid\"]),\n            right=Side(style=\"thin\", color=self.colors[\"grid\"]),\n            top=Side(style=\"thin\", color=self.colors[\"grid\"]),\n            bottom=Side(style=\"thin\", color=self.colors[\"grid\"]),\n        )\n\n        # Apply styles to data rows\n        for row in range(start_row, end_row + 1):\n            # Apply alternating row colors\n            if row % 2 == 0:\n                for col in range(1, num_cols + 1):\n                    worksheet.cell(row=row, column=col).fill = alt_fill\n\n            # Apply borders to all cells\n            for col in range(1, num_cols + 1):\n                worksheet.cell(row=row, column=col).border = thin_border\n                worksheet.cell(row=row, column=col).alignment = Alignment(\n                    horizontal=\"left\", vertical=\"center\"\n                )\n\n    def create_excel_table(self, worksheet, start_row, end_row, num_cols, table_name):\n        \"\"\"\n        Create an Excel table from the data range.\n\n        Args:\n            worksheet: The Excel worksheet.\n            start_row (int): Starting row number for table.\n            end_row (int): Ending row number for table.\n            num_cols (int): Number of columns.\n            table_name (str): Name for the table.\n        \"\"\"\n        # Define table range\n        table_ref = f\"A{start_row}:{get_column_letter(num_cols)}{end_row}\"\n\n        # Create table\n        table = Table(displayName=table_name, ref=table_ref)\n\n        # Add a default style\n        style = TableStyleInfo(\n            name=\"TableStyleMedium9\",\n            showFirstColumn=False,\n            showLastColumn=False,\n            showRowStripes=True,\n            showColumnStripes=False,\n        )\n        table.tableStyleInfo = style\n\n        # Add the table to the worksheet\n        worksheet.add_table(table)\n\n    def format_worksheet(self, worksheet, title):\n        \"\"\"\n        Apply general formatting to the worksheet.\n\n        Args:\n            worksheet: The Excel worksheet.\n            title (str): Title for the worksheet.\n        \"\"\"\n        # Set worksheet title\n        worksheet.title = title[:31]  # Excel limits worksheet names to 31 chars\n\n        # Add title at the top\n        title_cell = worksheet.cell(row=1, column=1)\n        title_cell.value = title\n        title_cell.font = Font(size=14, bold=True)\n\n        # Merge cells for title\n        worksheet.merge_cells(\"A1:D1\")\n        title_cell.alignment = Alignment(horizontal=\"center\")\n\n        # Add some space below title\n        worksheet.row_dimensions[2].height = 10\n\n\n# --- Tools ---\nclass Tools:\n    def __init__(self):\n        self.FILES_DIR = \"./tmp\"\n        self.API_BASE_URL = \"http://localhost:8080/api/v1/files/\"\n        os.makedirs(self.FILES_DIR, exist_ok=True)\n        self.help_functions = HelpFunctions()\n        self.event_emitter = EventEmitter()\n\n    async def generate_excel_from_json(\n        self,\n        json_data: dict,\n        __request__: Request,\n        __event_emitter__: Callable[[dict], Any] = None,\n        __user__=None,\n    ):\n        \"\"\"\n        Generate an Excel document from a JSON file.\n\n        Args:\n            json_data: The JSON data to generate the document from.\n            __user__: The user to upload the file to.\n        Returns:\n            str: The download URL of the uploaded file.\n\n        Example:\n        Here is an example of the JSON data for a complete Excel document:\n\n        ```json\n        {\n            \"titre\": \"Rapport financier\",\n            \"feuilles\": [\n                {\n                    \"nom\": \"Résumé\",\n                    \"tableau\": {\n                        \"colonnes\": [\"Mois\", \"Revenus\", \"Dépenses\", \"Profit\"],\n                        \"données\": [\n                            [\"Janvier\", 10000, 8000, 2000],\n                            [\"Février\", 12000, 7500, 4500],\n                            [\"Mars\", 15000, 9000, 6000]\n                        ]\n                    }\n                },\n                {\n                    \"nom\": \"Détails dépenses\",\n                    \"tableau\": {\n                        \"colonnes\": [\"Catégorie\", \"Montant\", \"Pourcentage\"],\n                        \"données\": [\n                            [\"Salaires\", 5000, \"60%\"],\n                            [\"Loyer\", 1500, \"20%\"],\n                            [\"Fournitures\", 800, \"10%\"],\n                            [\"Marketing\", 500, \"5%\"],\n                            [\"Divers\", 400, \"5%\"]\n                        ]\n                    }\n                }\n            ]\n        }\n        ```\n        \"\"\"\n        emitter = EventEmitter(__event_emitter__)\n        print(\"[DEBUG] json_data\", json_data)\n        titre = json_data.get(\"titre\")\n        print(\"[DEBUG] titre\", titre)\n        await emitter.emit(f\"Initiating Excel generation for: {titre}\")\n\n        # Create workbook\n        wb = Workbook()\n        print(\"[DEBUG] workbook created\")\n\n        # Remove default worksheet if we have sheets defined\n        if json_data.get(\"feuilles\") and len(json_data.get(\"feuilles\")) > 0:\n            if \"Sheet\" in wb.sheetnames:\n                del wb[\"Sheet\"]\n\n        # Process each sheet\n        try:\n            await emitter.emit(\"Creating Excel sheets and tables\")\n\n            for sheet_idx, sheet_data in enumerate(json_data.get(\"feuilles\", [])):\n                sheet_name = sheet_data.get(\"nom\", f\"Feuille {sheet_idx+1}\")\n\n                # Create new worksheet\n                if sheet_idx == 0 and \"Sheet\" in wb.sheetnames:\n                    # Use default sheet for first worksheet\n                    ws = wb.active\n                    ws.title = sheet_name\n                else:\n                    ws = wb.create_sheet(title=sheet_name)\n\n                print(f\"[DEBUG] Created sheet: {sheet_name}\")\n\n                # Format worksheet with title\n                self.help_functions.format_worksheet(\n                    ws, sheet_data.get(\"nom\", sheet_name)\n                )\n\n                # Process table data\n                if \"tableau\" in sheet_data:\n                    # Get table data\n                    table_data = sheet_data[\"tableau\"]\n                    columns = table_data.get(\"colonnes\", [])\n                    data_rows = table_data.get(\"données\", [])\n\n                    # Start position (after title and spacing)\n                    header_row = 3\n\n                    # Add header\n                    self.help_functions.format_header_row(ws, header_row, columns)\n\n                    # Add data\n                    for row_idx, row_data in enumerate(data_rows, header_row + 1):\n                        for col_idx, cell_value in enumerate(row_data, 1):\n                            ws.cell(row=row_idx, column=col_idx).value = cell_value\n\n                    # Format data rows\n                    if data_rows:\n                        end_row = header_row + len(data_rows)\n                        self.help_functions.format_data_rows(\n                            ws, header_row + 1, end_row, len(columns)\n                        )\n\n                        # Create Excel table\n                        table_name = f\"Table{sheet_idx}\".replace(\" \", \"\")\n                        try:\n                            self.help_functions.create_excel_table(\n                                ws, header_row, end_row, len(columns), table_name\n                            )\n                        except Exception as e:\n                            print(f\"[DEBUG] Could not create table: {e}\")\n\n                # Add simple formulas if it's a numeric table\n                if \"tableau\" in sheet_data:\n                    columns = sheet_data[\"tableau\"].get(\"colonnes\", [])\n                    data_rows = sheet_data[\"tableau\"].get(\"données\", [])\n\n                    if data_rows and len(data_rows) > 0:\n                        numeric_cols = []\n\n                        # Detect numeric columns\n                        for col_idx, _ in enumerate(columns, 1):\n                            if all(\n                                isinstance(row[col_idx - 1], (int, float))\n                                for row in data_rows\n                                if col_idx - 1 < len(row)\n                            ):\n                                numeric_cols.append(col_idx)\n\n                        # Add totals row with formulas\n                        if numeric_cols:\n                            total_row = header_row + len(data_rows) + 1\n                            ws.cell(row=total_row, column=1).value = \"Total\"\n                            ws.cell(row=total_row, column=1).font = Font(bold=True)\n\n                            for col_idx in numeric_cols:\n                                col_letter = get_column_letter(col_idx)\n                                start_row = header_row + 1\n                                end_row = header_row + len(data_rows)\n                                formula = f\"=SUM({col_letter}{start_row}:{col_letter}{end_row})\"\n                                ws.cell(row=total_row, column=col_idx).value = formula\n                                ws.cell(row=total_row, column=col_idx).font = Font(\n                                    bold=True\n                                )\n\n            await emitter.emit(\n                status=\"complete\",\n                description=f\"Excel generation completed\",\n                done=True,\n            )\n        except Exception as e:\n            print(\"[DEBUG] Error\", e)\n            return f\"Error: {str(e)}\"\n\n        # Save workbook\n        if not os.path.exists(self.FILES_DIR):\n            os.makedirs(self.FILES_DIR)\n        # clean up title for filename\n        clean_title = re.sub(r\"[^\\w\\s]\", \"\", json_data.get(\"titre\", \"excel\"))\n        clean_title = clean_title.replace(\" \", \"_\")\n\n        output_path = self.FILES_DIR + \"/\" + clean_title + \".xlsx\"\n        wb.save(output_path)\n        print(\"[DEBUG] output_path\", output_path)\n\n        try:\n            with open(output_path, \"rb\") as f:\n                print(\"[DEBUG] f\", f)\n                files = UploadFile(file=f, filename=os.path.basename(output_path))\n                print(\"[DEBUG] files\", files)\n                file_item = await self.upload_file(\n                    file=files,\n                    user_id=__user__[\"id\"],\n                    __request__=__request__,\n                    __user__=__user__,\n                    __event_emitter__=__event_emitter__,\n                )\n                print(\"[DEBUG] file_item\", file_item)\n                return file_item\n        except Exception as e:\n            print(\"[DEBUG] Error\", e)\n            return f\"Error: {str(e)}\"\n\n    async def upload_file(\n        self,\n        file: UploadFile,\n        user_id: str,\n        __request__: Request,\n        __user__: dict,\n        __event_emitter__: Callable[[dict], Any] = None,\n    ):\n        emitter = EventEmitter(__event_emitter__)\n        metadata = {\"data\": {\"generated_by\": \"upload_file\"}}\n\n        await emitter.emit(f\"Getting download link for file: {file.filename}\")\n\n        # get the user for permissions\n        user = Users.get_user_by_id(id=__user__[\"id\"])\n        print(\"[DEBUG] user\", user)\n        # upload the file to the database\n        doc = upload_file(\n            request=__request__,\n            file=file,\n            user=user,\n            file_metadata=metadata,\n            process=False,\n        )\n        print(\"[DEBUG] doc\", doc)\n\n        # get the download link\n        download_link = f\"{self.API_BASE_URL}{doc.id}/content\"\n        print(\"[DEBUG] download_link\", download_link)\n        await emitter.emit(\n            status=\"complete\",\n            description=f\"Finished generating the Excel file\",\n            done=True,\n        )\n        return (\n            f\"<source><source_id>{doc.filename}</source_id><source_context>\"\n            + str(download_link)\n            + \"</source_context></source>\\n\"\n        )\n","specs":[{"name":"generate_excel_from_json","description":"","parameters":{"properties":{"json_data":{"type":"object"}},"required":["json_data"],"type":"object"}},{"name":"upload_file","description":"","parameters":{"properties":{"file":{"format":"binary","type":"string"},"user_id":{"type":"string"}},"required":["file","user_id"],"type":"object"}}],"meta":{"description":"tool to generate excel files ( xlsx )","manifest":{"title":"Generate Excel Document","author":"openlab","version":"0.1","license":"MIT","description":"Génère un fichier Excel via un LLM (Ollama) et renvoie un lien de téléchargement"}},"access_control":{},"updated_at":1747297558,"created_at":1747297558},{"id":"generate_docx","user_id":"1f81ea87-3e74-4b85-a8ab-ca07d71d9ec0","name":"generate docx","content":"\"\"\"\ntitle: Generate DOCX Document\nauthor: openlab\nversion: 0.1\nlicense: MIT\ndescription: Génère un fichier DOCX via un LLM (Ollama) et renvoie un lien de téléchargement\n\"\"\"\n\nimport os, uuid\nfrom typing import Optional, Callable, Any\nfrom pathlib import Path\nfrom fastapi import UploadFile, Request\nimport re\nimport json\nfrom docx import Document\nfrom docx.shared import Inches, Pt, RGBColor, Cm\nfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENT, WD_LINE_SPACING\nfrom docx.enum.style import WD_STYLE_TYPE\nfrom docx.oxml.ns import qn\nfrom docx.oxml import OxmlElement\n\nfrom open_webui.routers.files import upload_file\nfrom open_webui.models.users import Users\nfrom open_webui.storage.provider import Storage\nfrom open_webui.models.files import Files, FileForm\n\n\nclass EventEmitter:\n    def __init__(self, event_emitter: Callable[[dict], Any] = None):\n        self.event_emitter = event_emitter\n\n    async def emit(self, description=\"Unknown State\", status=\"in_progress\", done=False):\n        if self.event_emitter:\n            await self.event_emitter(\n                {\n                    \"type\": \"status\",\n                    \"data\": {\n                        \"status\": status,\n                        \"description\": description,\n                        \"done\": done,\n                    },\n                }\n            )\n\n\nclass HelpFunctions:\n    def __init__(self):\n        self.styles = {\n            \"title\": \"Title\",\n            \"heading1\": \"Heading 1\",\n            \"heading2\": \"Heading 2\",\n            \"heading3\": \"Heading 3\",\n            \"normal\": \"Normal\",\n            \"subtitle\": \"Subtitle\",\n            \"toc\": \"TOC Heading\",\n        }\n        self.fonts = {\n            \"main\": \"Calibri\",\n            \"heading\": \"Arial\",\n            \"title\": \"Arial\",\n        }\n\n    def remove_tags_no_keep(self, text: str, start: str, end: str) -> str:\n        \"\"\"\n        Remove all text between two tags (`start` and `end`), tags included.\n\n        Parameters\n        ----------\n        text : str\n            text to remove tags from\n        start : str\n            starting tag\n        end : str\n            ending tag\n\n        Returns\n        -------\n        str\n            Text with tags removed\n        \"\"\"\n        return re.sub(r\"{}.*?{}\".format(start, end), \"\", text, flags=re.DOTALL).strip()\n\n    def upload_file(self, file: UploadFile, user_id: str):\n        \"\"\"\n        upload a file to the openwebui data base without the API (API doesn't work with the tools in version 0.6.5)\n        ARGS:\n            file: the file to upload\n            user_id: the id of the user\n        RETURNS:\n            the file item\n        \"\"\"\n        filename = file.filename\n        id = str(uuid.uuid4())\n        name = filename\n        filename = f\"{id}_{filename}\"\n        contents, file_path = Storage.upload_file(file.file, filename)\n\n        file_item = Files.insert_new_file(\n            user_id,\n            FileForm(\n                **{\n                    \"id\": id,\n                    \"filename\": name,\n                    \"path\": file_path,\n                    \"meta\": {\n                        \"name\": name,\n                        \"content_type\": file.content_type,\n                        \"size\": len(contents),\n                        \"data\": {\"generated_by\": \"upload_file\"},\n                    },\n                }\n            ),\n        )\n        print(f\"[DEBUG] File item: {file_item}\")\n\n        return file_item\n\n    def setup_document_styles(self, doc: Document) -> None:\n        \"\"\"\n        Configure document-wide styles for professional formatting\n\n        Args:\n            doc (Document): The Word document object.\n        \"\"\"\n        # Default paragraph style\n        style = doc.styles[\"Normal\"]\n        font = style.font\n        font.name = self.fonts[\"main\"]\n        font.size = Pt(11)\n        style.paragraph_format.alignment = WD_PARAGRAPH_ALIGNMENT.JUSTIFY\n        style.paragraph_format.line_spacing_rule = WD_LINE_SPACING.ONE_POINT_FIVE\n        style.paragraph_format.space_after = Pt(6)\n\n        # Heading styles\n        for i in range(1, 4):\n            style = doc.styles[f\"Heading {i}\"]\n            font = style.font\n            font.name = self.fonts[\"heading\"]\n            font.size = Pt(16 - (i - 1) * 2)  # 16pt, 14pt, 12pt\n            font.bold = True\n            style.paragraph_format.space_before = Pt(12)\n            style.paragraph_format.space_after = Pt(6)\n\n        # Title style\n        style = doc.styles[\"Title\"]\n        font = style.font\n        font.name = self.fonts[\"title\"]\n        font.size = Pt(24)\n        font.bold = True\n        style.paragraph_format.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER\n        style.paragraph_format.space_after = Pt(24)\n\n        # Subtitle style\n        style = doc.styles[\"Subtitle\"]\n        font = style.font\n        font.name = self.fonts[\"title\"]\n        font.size = Pt(18)\n        font.italic = True\n        style.paragraph_format.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER\n        style.paragraph_format.space_after = Pt(36)\n\n    def add_cover_page(\n        self,\n        doc: Document,\n        title: str,\n        subtitle: Optional[str] = None,\n        author: Optional[str] = None,\n        date: Optional[str] = None,\n        logo_path: Optional[str] = None,\n    ) -> None:\n        \"\"\"\n        Adds a professional cover page to the document.\n\n        Args:\n            doc (Document): The Word document object.\n            title (str): The main title of the document.\n            subtitle (str, optional): The subtitle or theme.\n            author (str, optional): The author or company name.\n            date (str, optional): The document date.\n            logo_path (str, optional): Path to a logo image.\n        \"\"\"\n        # Add page break if document already has content\n        if len(doc.paragraphs) > 0 and doc.paragraphs[0].text.strip():\n            doc.add_page_break()\n\n        # Add a blank paragraph for spacing at top\n        doc.add_paragraph()\n        doc.add_paragraph()\n\n        # Add title\n        title_para = doc.add_paragraph(title, style=\"Title\")\n        title_para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER\n\n        # Add subtitle if provided\n        if subtitle:\n            subtitle_para = doc.add_paragraph(subtitle, style=\"Subtitle\")\n            subtitle_para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER\n\n        # Add logo if path is provided\n        if logo_path and os.path.exists(logo_path):\n            try:\n                doc.add_picture(logo_path, width=Inches(2))\n                # Center the picture\n                last_paragraph = doc.paragraphs[-1]\n                last_paragraph.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER\n                last_paragraph.space_after = Pt(24)\n            except Exception as e:\n                print(f\"Error adding logo: {e}\")\n\n        # Add author information\n        if author:\n            author_para = doc.add_paragraph(f\"Auteur: {author}\")\n            author_para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER\n            author_para.space_after = Pt(12)\n\n        # Add date\n        if date:\n            date_para = doc.add_paragraph(date)\n            date_para.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER\n\n        # Add page break to start the main content on a new page\n        doc.add_page_break()\n\n    def add_table_of_contents(\n        self, doc: Document, title: str = \"Table des matières\"\n    ) -> None:\n        \"\"\"\n        Adds a table of contents to the document.\n\n        Args:\n            doc (Document): The Word document object.\n            title (str, optional): Title for the TOC. Defaults to \"Table des matières\".\n        \"\"\"\n        # Add heading for TOC\n        toc_heading = doc.add_paragraph(title, style=self.styles[\"heading1\"])\n        toc_heading.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER\n\n        # Add TOC field\n        para = doc.add_paragraph()\n        run = para.add_run()\n\n        # Add the TOC field code - corrected implementation\n        fldChar = OxmlElement(\"w:fldChar\")\n        fldChar.set(qn(\"w:fldCharType\"), \"begin\")\n\n        instrText = OxmlElement(\"w:instrText\")\n        instrText.set(qn(\"xml:space\"), \"preserve\")\n        instrText.text = (\n            'TOC \\\\o \"1-3\" \\\\h \\\\z \\\\u'  # Includes headings 1-3, with hyperlinks\n        )\n\n        fldChar2 = OxmlElement(\"w:fldChar\")\n        fldChar2.set(qn(\"w:fldCharType\"), \"separate\")\n\n        fldChar3 = OxmlElement(\"w:fldChar\")\n        fldChar3.set(qn(\"w:fldCharType\"), \"end\")\n\n        # Append all elements properly\n        run._element.append(fldChar)\n        run._element.append(instrText)\n        run._element.append(fldChar2)\n        run._element.append(fldChar3)\n\n        # Add page break after TOC\n        doc.add_page_break()\n\n    def add_title(self, doc: Document, title: str = \"Title\") -> None:\n        \"\"\"\n        Adds a title to the document.\n\n        Args:\n            doc (Document): The Word document object.\n            title (str, optional): The title text. Defaults to \"Title\".\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If the provided title is empty.\n        \"\"\"\n        # Check if the title is not empty\n        if not title.strip():\n            raise ValueError(\"Document title cannot be empty.\")\n\n        # Add title\n        title_paragraph = doc.add_paragraph(title, style=self.styles[\"title\"])\n        title_paragraph.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER\n\n    def add_heading(self, doc: Document, heading: str, level: int = 1) -> None:\n        \"\"\"\n        Adds a heading to the document.\n\n        Args:\n            doc (Document): The Word document object.\n            heading (str): The heading text.\n            level (int, optional): The heading level (1-3). Defaults to 1.\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If the heading is empty or level is invalid.\n        \"\"\"\n        # Check if the heading is not empty\n        if not heading.strip():\n            raise ValueError(\"Heading cannot be empty.\")\n\n        # Validate heading level\n        if level < 1 or level > 3:\n            raise ValueError(\"Heading level must be between 1 and 3.\")\n\n        # Map level to style\n        style = f\"heading{level}\"\n\n        # Add heading\n        doc.add_paragraph(heading, style=self.styles[style])\n\n    def add_paragraph_text(self, doc: Document, content: str) -> None:\n        \"\"\"\n        Adds a paragraph of text to the document, handling bullet points.\n\n        Args:\n            doc (Document): The Word document object.\n            content (str): The paragraph content.\n\n        Returns:\n            None\n        \"\"\"\n        if not content.strip():\n            return\n\n        lines = content.split(\"\\n\")\n\n        for line in lines:\n            level = 0\n            # Handle indentation\n            while line.startswith(\"    \"):\n                line = line[4:]\n                level += 1\n\n            # Handle bullet points\n            if line.startswith(\"* \") or line.startswith(\"• \"):\n                line = line[2:]\n                p = doc.add_paragraph(line, style=\"List Bullet\")\n                p.paragraph_format.left_indent = Pt(level * 18)\n            else:\n                p = doc.add_paragraph(line)\n                if level > 0:\n                    p.paragraph_format.left_indent = Pt(level * 18)\n                # Apply justified alignment and proper line spacing for regular paragraphs\n                p.paragraph_format.alignment = WD_PARAGRAPH_ALIGNMENT.JUSTIFY\n                p.paragraph_format.line_spacing_rule = WD_LINE_SPACING.ONE_POINT_FIVE\n\n    def add_section_header(self, doc: Document, title: str) -> None:\n        \"\"\"\n        Adds a formatted section header (like Introduction, Conclusion, etc.)\n\n        Args:\n            doc (Document): The Word document object.\n            title (str): The section header text.\n        \"\"\"\n        # Add heading with proper style\n        header = doc.add_paragraph(title, style=self.styles[\"heading1\"])\n        # Add a subtle horizontal line under the section header\n        # La méthode bottom_border n'existe pas directement, utilisons une approche alternative\n        pPr = header._p.get_or_add_pPr()\n        pBdr = OxmlElement(\"w:pBdr\")\n        bottom = OxmlElement(\"w:bottom\")\n        bottom.set(qn(\"w:val\"), \"single\")\n        bottom.set(qn(\"w:sz\"), \"6\")  # Taille de la bordure (~1pt)\n        bottom.set(qn(\"w:space\"), \"1\")\n        bottom.set(qn(\"w:color\"), \"000000\")  # Couleur noire\n        pBdr.append(bottom)\n        pPr.append(pBdr)\n\n        header.paragraph_format.space_after = Pt(12)\n\n    def add_bibliography(self, doc: Document, references: list) -> None:\n        \"\"\"\n        Adds a bibliography section with formatted references\n\n        Args:\n            doc (Document): The Word document object.\n            references (list): List of reference strings\n        \"\"\"\n        if not references:\n            return\n\n        # Add section header\n        self.add_section_header(doc, \"Bibliographie / Références\")\n\n        # Add each reference as a properly formatted paragraph\n        for ref in references:\n            p = doc.add_paragraph(ref)\n            p.paragraph_format.first_line_indent = Pt(-36)  # Hanging indent\n            p.paragraph_format.left_indent = Pt(36)\n            p.paragraph_format.space_after = Pt(6)\n\n\n# --- Tools ---\nclass Tools:\n    def __init__(self):\n        self.FILES_DIR = \"./tmp\"\n        self.API_BASE_URL = \"http://localhost:8080/api/v1/files/\"\n        self.template_path = \"./templates/template.docx\"\n        os.makedirs(self.FILES_DIR, exist_ok=True)\n        self.help_functions = HelpFunctions()\n        self.event_emitter = EventEmitter()\n\n    async def generate_docx_from_json(\n        self,\n        json_data: dict,\n        __request__: Request,\n        __event_emitter__: Callable[[dict], Any] = None,\n        __user__=None,\n    ):\n        \"\"\"\n        Generate a Word document from a JSON file.\n\n        Args:\n            json_data: The JSON data to generate the document from.\n            __user__: The user to upload the file to.\n        Returns:\n            str: The download URL of the uploaded file.\n\n        Example:\n        Here is an example of the JSON data for a complete document:\n\n        ```json\n        {\n            \"titre\": \"Titre du document\",\n            \"sous_titre\": \"Sous-titre explicatif\",\n            \"auteur\": \"Nom de l'auteur ou entreprise\",\n            \"date\": \"Octobre 2023\",\n            \"logo_path\": \"chemin/vers/logo.png\",\n            \"inclure_table_matieres\": true,\n            \"sections\": [\n                {\n                    \"type\": \"page_garde\",\n                    \"titre\": \"Titre principal\",\n                    \"sous_titre\": \"Sous-titre ou description\",\n                    \"auteur\": \"Nom ou société\",\n                    \"date\": \"Date de publication\"\n                },\n                {\n                    \"type\": \"introduction\",\n                    \"contenu\": \"Texte d'introduction...\\n* Point important\\n* Autre point important\"\n                },\n                {\n                    \"type\": \"heading\",\n                    \"titre\": \"Première partie\",\n                    \"niveau\": 1\n                },\n                {\n                    \"type\": \"contenu\",\n                    \"contenu\": \"Contenu de la première partie...\\n* Bullet list\\n    * Bullet list niveau 2\"\n                },\n                {\n                    \"type\": \"heading\",\n                    \"titre\": \"Sous-section\",\n                    \"niveau\": 2\n                },\n                {\n                    \"type\": \"conclusion\",\n                    \"contenu\": \"Texte de conclusion...\"\n                },\n                {\n                    \"type\": \"bibliographie\",\n                    \"references\": [\n                        \"Auteur, A. (2023). Titre de l'ouvrage. Éditeur.\",\n                        \"Auteur, B. (2022). Titre de l'article. Journal, 10(2), 45-67.\"\n                    ]\n                }\n            ]\n        }\n        ```\n        \"\"\"\n        emitter = EventEmitter(__event_emitter__)\n        print(\"[DEBUG] json_data\", json_data)\n        topic = json_data.get(\"titre\")\n        print(\"[DEBUG] topic\", topic)\n        await emitter.emit(f\"Initiating DOCX generation for topic: {topic}\")\n\n        # Create document\n        try:\n            doc = Document(self.template_path)\n        except:\n            doc = Document()  # Create a new document if template doesn't exist\n        print(\"[DEBUG] doc created\")\n\n        # Set up professional document styles\n        self.help_functions.setup_document_styles(doc)\n        print(\"[DEBUG] document styles configured\")\n\n        # Process document structure in order\n        try:\n            await emitter.emit(\"Creating document structure\")\n\n            # 1. Add cover page if data is provided\n            cover_data = next(\n                (\n                    s\n                    for s in json_data.get(\"sections\", [])\n                    if s.get(\"type\") == \"page_garde\"\n                ),\n                None,\n            )\n            if cover_data:\n                self.help_functions.add_cover_page(\n                    doc,\n                    title=cover_data.get(\"titre\", json_data.get(\"titre\")),\n                    subtitle=cover_data.get(\"sous_titre\", json_data.get(\"sous_titre\")),\n                    author=cover_data.get(\"auteur\", json_data.get(\"auteur\")),\n                    date=cover_data.get(\"date\", json_data.get(\"date\")),\n                    logo_path=json_data.get(\"logo_path\"),\n                )\n                print(\"[DEBUG] cover page added\")\n\n            # 2. Add table of contents if requested\n            if json_data.get(\"inclure_table_matieres\", False):\n                self.help_functions.add_table_of_contents(doc)\n                print(\"[DEBUG] table of contents added\")\n\n            # 3. Process each section in order\n            for section in json_data.get(\"sections\", []):\n                section_type = section.get(\"type\")\n                print(f\"[DEBUG] Processing section type: {section_type}\")\n\n                if section_type == \"page_garde\":\n                    # Already handled above\n                    continue\n\n                elif section_type == \"introduction\":\n                    self.help_functions.add_section_header(doc, \"Introduction\")\n                    self.help_functions.add_paragraph_text(\n                        doc, section.get(\"contenu\", \"\")\n                    )\n                    print(\"[DEBUG] introduction added\")\n\n                elif section_type == \"heading\":\n                    level = section.get(\"niveau\", 1)\n                    self.help_functions.add_heading(\n                        doc, heading=section.get(\"titre\"), level=level\n                    )\n                    print(\n                        f\"[DEBUG] heading level {level} added: {section.get('titre')}\"\n                    )\n\n                elif section_type == \"contenu\":\n                    self.help_functions.add_paragraph_text(\n                        doc, section.get(\"contenu\", \"\")\n                    )\n                    print(\"[DEBUG] content paragraph added\")\n\n                elif section_type == \"conclusion\":\n                    self.help_functions.add_section_header(doc, \"Conclusion\")\n                    self.help_functions.add_paragraph_text(\n                        doc, section.get(\"contenu\", \"\")\n                    )\n                    print(\"[DEBUG] conclusion added\")\n\n                elif section_type == \"bibliographie\":\n                    self.help_functions.add_bibliography(\n                        doc, section.get(\"references\", [])\n                    )\n                    print(\"[DEBUG] bibliography added\")\n\n            # 4. Add page numbers to the document (footer)\n            sections = doc.sections\n            for section in sections:\n                footer = section.footer\n                paragraph = footer.paragraphs[0]\n                paragraph.text = \"Page \"\n                run = paragraph.add_run()\n\n                # Correct way to create field codes for page numbers\n                fldChar1 = OxmlElement(\"w:fldChar\")\n                fldChar1.set(qn(\"w:fldCharType\"), \"begin\")\n\n                instrText = OxmlElement(\"w:instrText\")\n                instrText.set(qn(\"xml:space\"), \"preserve\")\n                instrText.text = \"PAGE\"\n\n                fldChar2 = OxmlElement(\"w:fldChar\")\n                fldChar2.set(qn(\"w:fldCharType\"), \"end\")\n\n                run._element.append(fldChar1)\n                run._element.append(instrText)\n                run._element.append(fldChar2)\n\n                paragraph.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER\n\n            await emitter.emit(\n                status=\"complete\",\n                description=f\"DOCX generation completed\",\n                done=True,\n            )\n        except Exception as e:\n            print(\"[DEBUG] Error\", e)\n            return f\"Error: {str(e)}\"\n\n        # Save document\n        if not os.path.exists(self.FILES_DIR):\n            os.makedirs(self.FILES_DIR)\n        # clean up title for filename\n        clean_title = re.sub(r\"[^\\w\\s]\", \"\", json_data.get(\"titre\", \"document\"))\n        clean_title = clean_title.replace(\" \", \"_\")\n\n        output_path = self.FILES_DIR + \"/\" + clean_title + \".docx\"\n        doc.save(output_path)\n        print(\"[DEBUG] output_path\", output_path)\n\n        try:\n            with open(output_path, \"rb\") as f:\n                print(\"[DEBUG] f\", f)\n                files = UploadFile(file=f, filename=os.path.basename(output_path))\n                print(\"[DEBUG] files\", files)\n                file_item = await self.upload_file(\n                    file=files,\n                    user_id=__user__[\"id\"],\n                    __request__=__request__,\n                    __user__=__user__,\n                    __event_emitter__=__event_emitter__,\n                )\n                print(\"[DEBUG] file_item\", file_item)\n                return file_item\n        except Exception as e:\n            print(\"[DEBUG] Error\", e)\n            return \"Error\"\n\n    async def upload_file(\n        self,\n        file: UploadFile,\n        user_id: str,\n        __request__: Request,\n        __user__: dict,\n        __event_emitter__: Callable[[dict], Any] = None,\n    ):\n        emitter = EventEmitter(__event_emitter__)\n        metadata = {\"data\": {\"generated_by\": \"upload_file\"}}\n\n        await emitter.emit(f\"Getting download link for file: {file.filename}\")\n\n        # get the user for permissions\n        user = Users.get_user_by_id(id=__user__[\"id\"])\n        print(\"[DEBUG] user\", user)\n        # upload the file to the database\n        doc = upload_file(\n            request=__request__,\n            file=file,\n            user=user,\n            file_metadata=metadata,\n            process=False,\n        )\n        print(\"[DEBUG] doc\", doc)\n\n        # get the download link\n        download_link = f\"{self.API_BASE_URL}{doc.id}/content\"\n        print(\"[DEBUG] download_link\", download_link)\n        await emitter.emit(\n            status=\"complete\",\n            description=f\"Finished generating the DOCX file\",\n            done=True,\n        )\n        return (\n            f\"<source><source_id>{doc.filename}</source_id><source_context>\"\n            + str(download_link)\n            + \"</source_context></source>\\n\"\n        )\n","specs":[{"name":"generate_docx_from_json","description":"","parameters":{"properties":{"json_data":{"type":"object"}},"required":["json_data"],"type":"object"}},{"name":"upload_file","description":"","parameters":{"properties":{"file":{"format":"binary","type":"string"},"user_id":{"type":"string"}},"required":["file","user_id"],"type":"object"}}],"meta":{"description":"generates word documents ( docx )","manifest":{"title":"Generate DOCX Document","author":"openlab","version":"0.1","license":"MIT","description":"Génère un fichier DOCX via un LLM (Ollama) et renvoie un lien de téléchargement"}},"access_control":{},"updated_at":1747296572,"created_at":1747294455},{"id":"generate_file","user_id":"1f81ea87-3e74-4b85-a8ab-ca07d71d9ec0","name":"generate file","content":"\"\"\"\ntitle: Generate a file\nauthor: openlab\nversion: 0.1\nlicense: MIT\ndescription: allows to generate and give a download link\n\"\"\"\n\nimport os, uuid\nfrom pydantic import BaseModel, Field\nfrom open_webui.storage.provider import Storage\nfrom open_webui.models.files import Files\nfrom open_webui.models.files import FileForm\n\nfrom fastapi import UploadFile\n\n\nclass Tools:\n\n    def __init__(self):\n        self.API_BASE_URL = \"http://localhost:8080/api/v1/files/\"\n        self.API_KEY = \"sk-dcb0e2b13ee54211866423020dd9bf59\"\n        self.FILES_DIR = \"./tmp\"\n        self.TIMEOUT = 10\n\n    def create_file(\n        self,\n        file_name: str,\n        file_content: str,\n        file_extension: str = None,\n        __user__=None,\n    ):\n        \"\"\"\n        Create a file with the given name and content.\n        Handles different file extensions appropriately.\n        When you use this function make sure the always give to the user the link to download the file\n\n        Args:\n            file_name: Name of the file to create\n            file_content: Content to write to the file\n            file_extension: Optional extension to append if not already in file_name\n        Returns:\n            the download link of the file generated always send this to the user\n        \"\"\"\n\n        # If extension is provided and not already in file_name, append it\n        if file_extension and not file_name.endswith(f\".{file_extension}\"):\n            file_name = f\"{file_name}.{file_extension}\"\n\n        file_path = os.path.abspath(file_name)\n        if not os.path.exists(self.FILES_DIR):\n            os.makedirs(self.FILES_DIR)\n\n        # Determine if the file is binary or text based on extension\n        binary_extensions = [\"pdf\", \"png\", \"jpg\", \"jpeg\", \"gif\", \"zip\", \"exe\", \"bin\"]\n        is_binary = file_extension and file_extension.lower() in binary_extensions\n        file_path = os.path.join(self.FILES_DIR, file_name)\n        print(f\"[DEBUG] File path: {file_path}\")\n        # Write the file with appropriate mode\n        if is_binary:\n            # For binary files, content should be properly encoded\n            with open(file_path, \"wb\") as f:\n                # Assuming content might be base64 encoded for binary files\n                try:\n                    import base64\n\n                    f.write(base64.b64decode(file_content))\n                except:\n                    # Fallback if not base64 encoded\n                    f.write(file_content.encode(\"utf-8\"))\n        else:\n            # For text files\n            with open(file_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(file_content)\n        print(f\"[DEBUG] File created: {file_path}\")\n\n        # Upload the file to the OpenAI API\n        download_link = self.get_file_download_link(file_path, __user__)\n        return f\"This is the dowload link for the {file_name} : {download_link}\"\n\n    # Method to download a filde using the openwebui api.\n    def get_file_download_link(self, file: str, __user__=None):\n        \"\"\"\n        get the download link of a file\n        it utilise the openwebui api to upload the file and get the download link\n        ARGS:\n            file: the path to the file to upload\n        RETURNS:\n            the download link of the file\n        \"\"\"\n        try:\n            file_path = os.path.abspath(file)\n            print(f\"[DEBUG] File path: {file_path}\")\n            headers = {\n                \"accept\": \"application/json\",\n                \"Authorization\": f\"Bearer {self.API_KEY}\",\n            }\n            url = f\"{self.API_BASE_URL}\"  # Remove trailing slash\n            print(f\"[DEBUG] URL: {url}\")\n            print(f\"[DEBUG] Headers: {headers}\")\n\n            file_id = \"\"\n            try:\n                with open(file, \"rb\") as f:\n                    files = UploadFile(file=f, filename=os.path.basename(file))\n                    # files = {\"file\": f,\"filename\": os.path.basename(file),\"content_type\": \"application/octet-stream\"}\n                    print(f\"[DEBUG] Files: {files}\")\n                    # Use direct requests instead of self.post for more contro\n                    response = self.upload_file(files, __user__[\"id\"])\n                    print(f\"[DEBUG] Response: {response}\")\n\n                    # Parse the response\n                    file_id = response.id\n                    print(f\"[DEBUG] File ID: {file_id}\")\n                    if not file_id:\n                        return {\"error\": \"No file ID returned from upload\"}\n\n            except Exception as e:\n                print(f\"[DEBUG] Error uploading file: {str(e)}\")\n                return {\"error\": f\"Error uploading file: {str(e)}\"}\n\n            download_url = f\"{self.API_BASE_URL}{file_id}/content\"\n            print(f\"[DEBUG] Download URL: {download_url}\")\n            # delete the file from the local directory\n            # os.remove(file_path)\n            print(f\"[DEBUG] File {file_path} deleted\")\n            return download_url\n        except Exception as e:\n            # os.remove(file_path)\n            print(f\"[DEBUG] Error in download_file_openwebui: {str(e)}\")\n            return {\"error\": f\"Error in download_file_openwebui: {str(e)}\"}\n\n    def upload_file(self, file: UploadFile, user_id: str):\n        \"\"\"\n        upload a file to the openwebui data base without the API (API doesn't work with the tools in version 0.6.5)\n        ARGS:\n            file: the file to upload\n            user_id: the id of the user\n        RETURNS:\n            the file item\n        \"\"\"\n        filename = file.filename\n        id = str(uuid.uuid4())\n        name = filename\n        filename = f\"{id}_{filename}\"\n        contents, file_path = Storage.upload_file(file.file, filename)\n\n        file_item = Files.insert_new_file(\n            user_id,\n            FileForm(\n                **{\n                    \"id\": id,\n                    \"filename\": name,\n                    \"path\": file_path,\n                    \"meta\": {\n                        \"name\": name,\n                        \"content_type\": file.content_type,\n                        \"size\": len(contents),\n                        \"data\": {\"generated_by\": \"upload_file\"},\n                    },\n                }\n            ),\n        )\n        print(f\"[DEBUG] File item: {file_item}\")\n\n        return file_item\n","specs":[{"name":"create_file","description":"","parameters":{"properties":{"file_name":{"type":"string"},"file_content":{"type":"string"},"file_extension":{"default":null,"type":"string"}},"required":["file_name","file_content"],"type":"object"}},{"name":"get_file_download_link","description":"","parameters":{"properties":{"file":{"type":"string"}},"required":["file"],"type":"object"}},{"name":"upload_file","description":"","parameters":{"properties":{"file":{"format":"binary","type":"string"},"user_id":{"type":"string"}},"required":["file","user_id"],"type":"object"}}],"meta":{"description":"Generates files then provide the download url ","manifest":{"title":"Generate a file","author":"openlab","version":"0.1","license":"MIT","description":"allows to generate and give a download link"}},"access_control":{},"updated_at":1747144623,"created_at":1745499727}]